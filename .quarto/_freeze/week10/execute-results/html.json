{
  "hash": "91b5f0014129f82335d07a88629a92fc",
  "result": {
    "markdown": "---\ntitle: \"More Linear Regression; Logistic Regression\"\n---\n\n\n\n\n## Recap week 9: Linear Regression\n- Textbook section 8.2 Linear Regression\n- Textbook section 8.4 Inference for Linear Regression\n- Textbook section 9.1 Multiple Regression\n\n## More on Multiple regression\nThe OpenIntro Stats book gives an example of multiple regression with the `mariokart` data frame from their website. This involves the sale of 143 copies of the game *Mario Kart* for the Wii platform on eBay. They first predict the price based on most of the variables, like so.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(paste0(Sys.getenv(\"STATS_DATA_DIR\"),\"/mariokart.rda\"))\nm<-(lm(total_pr~cond+stock_photo+duration+wheels,data=mariokart))\nsummary(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = total_pr ~ cond + stock_photo + duration + wheels, \n    data = mariokart)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-19.485  -6.511  -2.530   1.836 263.025 \n\nCoefficients:\n               Estimate Std. Error t value Pr(>|t|)    \n(Intercept)     43.5201     8.3701   5.199 7.05e-07 ***\ncondused        -2.5816     5.2272  -0.494 0.622183    \nstock_photoyes  -6.7542     5.1729  -1.306 0.193836    \nduration         0.3788     0.9388   0.403 0.687206    \nwheels           9.9476     2.7184   3.659 0.000359 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 24.4 on 138 degrees of freedom\nMultiple R-squared:  0.1235,\tAdjusted R-squared:  0.09808 \nF-statistic:  4.86 on 4 and 138 DF,  p-value: 0.001069\n```\n:::\n\n```{.r .cell-code}\nplot(m)\n```\n\n::: {.cell-output-display}\n![](week10_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](week10_files/figure-html/unnamed-chunk-2-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](week10_files/figure-html/unnamed-chunk-2-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](week10_files/figure-html/unnamed-chunk-2-4.png){width=672}\n:::\n:::\n\n\nThere are four diagnostic plots in the above output. Each one gives us information about the quality of the model.\n\n### Residuals vs Fitted\nThis plot tells you the magnitude of the difference between the residuals and the fitted values. There are three things to watch for here. First, are there any drastic outliers? Yes, there are two, points 65 and 20. (Those are row numbers in the data frame.) You need to investigate those and decide whether to omit them from further analysis. Were they typos? Mismeasurements? Or is the process from which they derive intrinsically subject to occasional extreme variation. In the third case, you probably don't want to omit them.\n\nSecond, is the solid red line near the dashed zero line? Yes it is, indicating that the residuals have a mean of approximately zero. (The red line shows the mean of the residuals in the immediate region of the $x$-values of the observed data.)\n\nThird, is there a pattern to the residuals? No, there is not. The residuals appear to be of the same general magnitude at one end as the other. The things that would need action would be a curve or multiple curves, or a widening or narrowing shape, like the cross section of a horn.\n\n### Normal Q-Q\nThis is an important plot. I see many students erroneously claiming that residuals are normally distributed because they have a vague bell shape. That is not good enough to detect normality. The Q-Q plot is the standard way to detect normality. If the points lie along the dashed line, you can be reasonably safe in an assumption of normality. If they deviate from the dashed line, the residuals are probably not normally distributed.\n\n### Scale-Location\nLook for two things here. First, the red line should be approximately horizontal, meaning that there is not much variability in the standardized residuals. Second, look at the spread of the points around the red line. If they don't show a pattrn, this reinforces the assumption of homoscedasticity that we already found evidence for in the first plot.\n\n### Residuals vs Leverage\nThis shows you influential points that you may want to remove. Point 84 has high leverage (potential for influence) but is probably not actually very influential because it is so far from Cook's Distance. Points 20 and 65 are outliers but only point 20 is more than Cook's Distance away from the mean. In this case, you would likely remove point 20 from consideration unless there were a mitigating reason. For example, game collectors often pay extra for a game that has unusual attributes, such as shrink-wrapped original edition. As an example of a point you would definitely remove, draw a horizontal line from point 20 to a vertical line from point 84. Where they meet would be a high-leverage outlier that is unduly affecting the model no matter what it's underlying cause. On the other hand, what if you have many such points? Unfortunately, that probably means the model isn't very good.\n\n### Removing offending observations\nSuppose we want to get rid of points 20 and 65 and rerun the regression. We could either do this using plain R or the tidyverse. I prefer the tidyverse method because of clarity of exposition.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- mariokart |>\n  filter(!row_number() %in% c(20, 65))\nm<-(lm(total_pr~cond+stock_photo+duration+wheels,data=df))\nsummary(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = total_pr ~ cond + stock_photo + duration + wheels, \n    data = df)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-11.3788  -2.9854  -0.9654   2.6915  14.0346 \n\nCoefficients:\n               Estimate Std. Error t value Pr(>|t|)    \n(Intercept)    41.34153    1.71167  24.153  < 2e-16 ***\ncondused       -5.13056    1.05112  -4.881 2.91e-06 ***\nstock_photoyes  1.08031    1.05682   1.022    0.308    \nduration       -0.02681    0.19041  -0.141    0.888    \nwheels          7.28518    0.55469  13.134  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.901 on 136 degrees of freedom\nMultiple R-squared:  0.719,\tAdjusted R-squared:  0.7108 \nF-statistic: 87.01 on 4 and 136 DF,  p-value: < 2.2e-16\n```\n:::\n\n```{.r .cell-code}\nplot(m)\n```\n\n::: {.cell-output-display}\n![](week10_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](week10_files/figure-html/unnamed-chunk-3-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](week10_files/figure-html/unnamed-chunk-3-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](week10_files/figure-html/unnamed-chunk-3-4.png){width=672}\n:::\n:::\n\n\nWhat a difference this makes in the output and the statistics and plots about the output!\nKeep in mind, though, that I just did this as an example. Points 20 and 65 may be totally legitimate in this case. Also, note that you could use plain R without the tidyverse to eliminate those rows by saying something like `df <- mariokart[-c(20,65),]`. The bracket notation assumes anything before the comma refers to a row and anything after a comma refers to a column. In this case, I didn't say anything about the columns, so the square brackets just have a dangling comma in them. The important point is that one method or another may seem more natural to you. For most students, the tidyverse approach is probably more natural, so I highlight that.\n\n## Logistic Regression\nLogistic regression is a kind classification rather than regression. The book doesn't make this point, but most textbooks do. You can divide machine learning problems into problems of regression and problems of classification. In regression, the $y$ variable is more or less continuous, whereas in the classification problem, $y$ is a set of categories, ordered or not. The word logistic comes from the logistic function, which is illustrated below. This interesting function takes an input from $-\\infty$ to $+\\infty$ and gives an output between zero and one. It can be used to reduce wildly varying inputs into a yes / no decision. It is also known as the sigmoid function.\n\n\n::: {.cell engine.opts='{\"extra.preamble\":[\"\\\\usepackage{pgfplots}\",\"\\\\pgfplotsset{compat=1.18}\"]}'}\n::: {.cell-output-display}\n![](week10_files/figure-html/unnamed-chunk-4-1.png){width=50%}\n:::\n:::\n\n\nNote that zero and one happen to be the boundaries of a probability measure. Hence, you can use the logistic function to reduce arbitrary numbers to a probability.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(paste0(Sys.getenv(\"STATS_DATA_DIR\"),\"/resume.rda\"))\nnames(resume)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"job_ad_id\"              \"job_city\"               \"job_industry\"          \n [4] \"job_type\"               \"job_fed_contractor\"     \"job_equal_opp_employer\"\n [7] \"job_ownership\"          \"job_req_any\"            \"job_req_communication\" \n[10] \"job_req_education\"      \"job_req_min_experience\" \"job_req_computer\"      \n[13] \"job_req_organization\"   \"job_req_school\"         \"received_callback\"     \n[16] \"firstname\"              \"race\"                   \"gender\"                \n[19] \"years_college\"          \"college_degree\"         \"honors\"                \n[22] \"worked_during_school\"   \"years_experience\"       \"computer_skills\"       \n[25] \"special_skills\"         \"volunteer\"              \"military\"              \n[28] \"employment_holes\"       \"has_email_address\"      \"resume_quality\"        \n```\n:::\n\n```{.r .cell-code}\nwith(resume,table(race,received_callback))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       received_callback\nrace       0    1\n  black 2278  157\n  white 2200  235\n```\n:::\n\n```{.r .cell-code}\nwith(resume,table(gender,received_callback))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      received_callback\ngender    0    1\n     f 3437  309\n     m 1041   83\n```\n:::\n\n```{.r .cell-code}\nwith(resume,table(honors,received_callback))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      received_callback\nhonors    0    1\n     0 4263  350\n     1  215   42\n```\n:::\n\n```{.r .cell-code}\nsummary(glm(received_callback ~ honors,data=resume,family=\"binomial\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nglm(formula = received_callback ~ honors, family = \"binomial\", \n    data = resume)\n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept)  -2.4998     0.0556  -44.96  < 2e-16 ***\nhonors        0.8668     0.1776    4.88 1.06e-06 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 2726.9  on 4869  degrees of freedom\nResidual deviance: 2706.7  on 4868  degrees of freedom\nAIC: 2710.7\n\nNumber of Fisher Scoring iterations: 5\n```\n:::\n\n```{.r .cell-code}\nsummary(glm(received_callback ~ race,data=resume,family=\"binomial\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nglm(formula = received_callback ~ race, family = \"binomial\", \n    data = resume)\n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept) -2.67481    0.08251 -32.417  < 2e-16 ***\nracewhite    0.43818    0.10732   4.083 4.45e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 2726.9  on 4869  degrees of freedom\nResidual deviance: 2709.9  on 4868  degrees of freedom\nAIC: 2713.9\n\nNumber of Fisher Scoring iterations: 5\n```\n:::\n\n```{.r .cell-code}\nsummary(glm(received_callback ~ gender,data=resume,family=\"binomial\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nglm(formula = received_callback ~ gender, family = \"binomial\", \n    data = resume)\n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept) -2.40901    0.05939 -40.562   <2e-16 ***\ngenderm     -0.12008    0.12859  -0.934     0.35    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 2726.9  on 4869  degrees of freedom\nResidual deviance: 2726.0  on 4868  degrees of freedom\nAIC: 2730\n\nNumber of Fisher Scoring iterations: 5\n```\n:::\n:::\n\n\n### `tidymodels` approach\nDatacamp shows a different way, using `tidymodels` in one of their [tutorials](https://www.datacamp.com/tutorial/logistic-regression-R).\nIn this example, the bank wants to divide customers into those likely to buy and those unlikely to buy some banking product. They would like to divide the customers into these two groups using logistic regression, with a cutoff point of fifty-fifty. If there's better than a fifty-fifty chance, they will send a salesperson but if there's less than a fifty-fifty chance, they won't send a salesperson.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidymodels)\n\n#. Read the dataset and convert the target variable to a factor\nbank_df <- read_csv2(paste0(Sys.getenv(\"STATS_DATA_DIR\"),\"/bank-full.csv\"))\nbank_df$y = as.factor(bank_df$y)\n\n#. Plot job occupation against the target variable\nggplot(bank_df, aes(job, fill = y)) +\n    geom_bar() +\n    coord_flip()\n```\n\n::: {.cell-output-display}\n![](week10_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nA crucial concept you'll learn if you take a more advanced class, say 310D, is the notion of dividing data into two data frames, a training frame and a test frame. This is the conventional way to test machine learning models, of which logistic regression is one. You train the model on one set of data, then test it on another, previously unseen set. That's the next thing done in this example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#. Split data into train and test\nset.seed(421)\nsplit <- initial_split(bank_df, prop = 0.8, strata = y)\ntrain <- split |> \n         training()\ntest <- split |>\n        testing()\n#. Train a logistic regression model\nm <- logistic_reg(mixture = double(1), penalty = double(1)) |>\n  set_engine(\"glmnet\") |>\n  set_mode(\"classification\") |>\n  fit(y ~ ., data = train)\n\n#. Model summary\ntidy(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 43 × 3\n   term              estimate penalty\n   <chr>                <dbl>   <dbl>\n 1 (Intercept)      -2.59           0\n 2 age              -0.000477       0\n 3 jobblue-collar   -0.183          0\n 4 jobentrepreneur  -0.206          0\n 5 jobhousemaid     -0.270          0\n 6 jobmanagement    -0.0190         0\n 7 jobretired        0.360          0\n 8 jobself-employed -0.101          0\n 9 jobservices      -0.105          0\n10 jobstudent        0.415          0\n# ℹ 33 more rows\n```\n:::\n\n```{.r .cell-code}\n#. Class Predictions\npred_class <- predict(m,\n                      new_data = test,\n                      type = \"class\")\n\n#. Class Probabilities\npred_proba <- predict(m,\n                      new_data = test,\n                      type = \"prob\")\nresults <- test |>\n           select(y) |>\n           bind_cols(pred_class, pred_proba)\n\naccuracy(results, truth = y, estimate = .pred_class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n  .metric  .estimator .estimate\n  <chr>    <chr>          <dbl>\n1 accuracy binary         0.902\n```\n:::\n:::\n\n\n### Hyperparameter tuning\nThere are aspects of this approach, called hyperparameters, that influence the quality of the model. It can be tedious to adjust these aspects, called penalty and mixture, so here's a technique for doing it automatically. You'll learn about this and similar techniques if you take a more advanced course like 310D, Intro to Data Science.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#. Define the logistic regression model with penalty and mixture hyperparameters\nlog_reg <- logistic_reg(mixture = tune(), penalty = tune(), engine = \"glmnet\")\n\n#. Define the grid search for the hyperparameters\ngrid <- grid_regular(mixture(), penalty(), levels = c(mixture = 4, penalty = 3))\n\n#. Define the workflow for the model\nlog_reg_wf <- workflow() |>\n  add_model(log_reg) |>\n  add_formula(y ~ .)\n\n#. Define the resampling method for the grid search\nfolds <- vfold_cv(train, v = 5)\n\n#. Tune the hyperparameters using the grid search\nlog_reg_tuned <- tune_grid(\n  log_reg_wf,\n  resamples = folds,\n  grid = grid,\n  control = control_grid(save_pred = TRUE)\n)\n\nselect_best(log_reg_tuned, metric = \"roc_auc\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n       penalty mixture .config              \n         <dbl>   <dbl> <chr>                \n1 0.0000000001       0 Preprocessor1_Model01\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#. Fit the model using the optimal hyperparameters\nlog_reg_final <- logistic_reg(penalty = 0.0000000001, mixture = 0) |>\n                 set_engine(\"glmnet\") |>\n                 set_mode(\"classification\") |>\n                 fit(y~., data = train)\n\n#. Evaluate the model performance on the testing set\npred_class <- predict(log_reg_final,\n                      new_data = test,\n                      type = \"class\")\nresults <- test |>\n  select(y) |>\n  bind_cols(pred_class, pred_proba)\n\n#. Create confusion matrix\nconf_mat(results, truth = y,\n         estimate = .pred_class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Truth\nPrediction   no  yes\n       no  7838  738\n       yes  147  320\n```\n:::\n\n```{.r .cell-code}\nprecision(results, truth = y,\n          estimate = .pred_class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n  .metric   .estimator .estimate\n  <chr>     <chr>          <dbl>\n1 precision binary         0.914\n```\n:::\n\n```{.r .cell-code}\nrecall(results, truth = y,\n          estimate = .pred_class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 recall  binary         0.982\n```\n:::\n:::\n\n\n### Evaluation metrics\nFollowing are two tables from @James2021 that you can use to evaluate a classification model.\n\n![](fiConfMatr.png)\n\n![](fiPrecisionRecall.png)\n\nAnother view is provided at [Wikipedia](https://en.wikipedia.org/wiki/Precision_and_recall) in the following picture\n\n![](fiPrecisionRecallPicture.png){fig-align=\"center\" width=50%}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoeff <- tidy(log_reg_final) |>\n  arrange(desc(abs(estimate))) |>\n  filter(abs(estimate) > 0.5)\ncoeff\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 3\n   term            estimate      penalty\n   <chr>              <dbl>        <dbl>\n 1 (Intercept)       -2.59  0.0000000001\n 2 poutcomesuccess    2.08  0.0000000001\n 3 monthmar           1.62  0.0000000001\n 4 monthoct           1.08  0.0000000001\n 5 monthsep           1.03  0.0000000001\n 6 contactunknown    -1.01  0.0000000001\n 7 monthdec           0.861 0.0000000001\n 8 monthjan          -0.820 0.0000000001\n 9 housingyes        -0.550 0.0000000001\n10 monthnov          -0.517 0.0000000001\n```\n:::\n\n```{.r .cell-code}\nggplot(coeff, aes(x = term, y = estimate, fill = term)) +\n  geom_col() +\n  coord_flip()\n```\n\n::: {.cell-output-display}\n![](week10_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "week10_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}